# aydoo2016-tpfinal
Repositorio de Gonzalo Alejandro Cozzi para el trabajo práctico final de AyDOO 2016.

# Aclaraciones sobre el trabajo práctico

## Sobre el diseño
* Para modelar la relación entre los objetos espaciales (o voladores, en la consigna del trabajo) y las colisiones, decidí crear un 'hash' en cada uno de estos objetos. Por defecto, ellos tienen establecida una relación con cada uno de los objetos del dominio, la cual se manifiesta al ocurrir una colisión, tal como figuran en la tabla de la consigna. De esta forma, la consecuencia de cada colisión es conocida por cada objeto espacial.
* La consecuencia de una colisión se modela en las clases 'Efecto'. Todos los efectos ejercen un cambio en uno de los dos atributos de los objetos espaciales, la 'vida' y la 'masa'. Para ello, reciben un puntero al objeto u objetos a modificar y le aplican el cambio al atributo correspondiente. Algunos efectos se aplican en los dos objetos voladores implicados en la colisión, otros lo hacen únicamente sobre uno de los objetos implicados. Además, esta modificación puede o no ser relativa a un atributo del otro objeto volador implicado en la colisión.
* Cada objeto espacial puede agregar y quitar relaciones objeto espacial-efecto del hash que poseen. Esto permite extender funcionalidad sin violar el principio Open/Close.
* Se pueden definir libremente nuevos efectos, siempre que modifiquen únicamente uno de los dos atributos de la clase. Esta decisión de diseño presupone que los nuevos efectos que pudieran surgir no modificarán masa Y vida. Tal problema puede resolverse implementando en la clase 'Efecto' una lista de argumentos, la cual permitiría agregar argumentos a modificar sin límite de número.
* La clase 'Colisión' le indica a los dos objetos espaciales implicados en la colisión que han colisionado con el otro objeto volador. Por ejemplo, una colisión entre una nave y una estrella le indica a 'nave' que ha colisionado con 'estrella', y a 'estrella' que ha colisionado con 'nave'. No hay un objeto que colisiona y un objeto que es colisionado, ambos colisionan al otro en igualdad de condiciones, y esto puede verse reflejado en que colisionar(nave, misil) == colisionar(misil, nave).
* El estado de un objeto volador solamente se define como 'vivo' o 'muerto', y no está modelado más que por un booleano. Esta decisión de diseño presupone que la nave no adoptará otros estados. En tal caso, deberá aplicarse un patrón de tipo 'State' para los objetos espaciales.
* Se aplicó herencia con la clase 'ObjetoEspacial' y con 'Efecto'. Los 5 objetos voladores definidos SON objetos espaciales, y los efectos definidos SON efectos. La limitación a un atributo modificable por parte de la clase 'Efecto' se explicó antes y no se considera como un eje central a resolver en el trabajo práctico.

## Smells
* La clase 'ObjetoEspacial' posee el método 'definir_estado', el cual tiene dos ifs que, a primera vista, parecieran poder unirse en uno solo. Esto no es posible, porque cada uno verifica si 'vida' y 'masa' es negativa y, en caso afirmativo, la pone en 0. En caso de agregar más atributos esto se vuelve inaceptable, y una forma de resolverlo es colocar los atributos en un arreglo.
* La clase 'ObjetoEspacial' tiene un if anidado en el método 'initialize', el cual fue agregado porque no pueden sobrecargarse métodos en Ruby, y esta clase y sus hijas, junto con sus correspondientes pruebas, ya existían al momento de indicarse que debían inicializarse con vida y masa en 100 unidades, condición que no figuraba en la consigna original. Se prefirió esta opción frente a la sobrecarga del operador 'new', la cual implicaba modificar decenas de pruebas ya existentes.
* Debido a que pertenece al dominio, se creó una clase 'EfectoNulo' que no tiene estado ni comportamiento. Su existencia a mi criterio es discutible, y reside en intentar mantener la claridad del código. De hecho, puede ser reemplazada con otros efectos configurados para no producir cambios.
* El significado de los parámetros que reciben los efectos depende del tipo de efecto a provocar. Puede ser un número entero o bien un flotante, el cual se aplica en efectos que aplican cambios porcentuales. Para explicar esto, se agregó en cada efecto un breve comentario con el significado del parámetro recibido.
* Los diagramas de clase y secuencia fueron hecho utilizando la herramienta Astah, la cual está preparada para realizar diagramas de programas Java. Debido a esto, aparecen expresiones incorrectas en Ruby, como 'void' y tipos estáticos. Se presupone que esto no será un impedimento para comprender el funcionamiento del programa en dichos diagramas.
* Por problemas de tiempo, no se modelaron algunas excepciones que corresponderían a los efectos. Por ejemplo, el usuario no debería pasar un entero negativo a un efecto constructivo, ya que se tendría efecto destructivo (bajaría la vida en vez de subirla).
